/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.azure.marketplace.implementation;

import retrofit2.Retrofit;
import com.azure.marketplace.SubscriptionOperations;
import com.azure.marketplace.models.Operation;
import com.azure.marketplace.models.OperationList;
import com.azure.marketplace.models.UpdateOperation;
import com.azure.marketplace.models.UpdateOperationStatusEnum;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.CloudException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in SubscriptionOperations.
 */
public class SubscriptionOperationsImpl implements SubscriptionOperations {
    /** The Retrofit service to perform REST calls. */
    private SubscriptionOperationsService service;
    /** The service client containing this operation class. */
    private MarketplaceClientImpl client;

    /**
     * Initializes an instance of SubscriptionOperationsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SubscriptionOperationsImpl(Retrofit retrofit, MarketplaceClientImpl client) {
        this.service = retrofit.create(SubscriptionOperationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for SubscriptionOperations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SubscriptionOperationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.SubscriptionOperations listOperations" })
        @GET("saas/subscriptions/{subscriptionId}/operations")
        Observable<Response<ResponseBody>> listOperations(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.SubscriptionOperations getOperationStatus" })
        @GET("saas/subscriptions/{subscriptionId}/operations/{operationId}")
        Observable<Response<ResponseBody>> getOperationStatus(@Path("subscriptionId") UUID subscriptionId, @Path("operationId") UUID operationId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.SubscriptionOperations updateOperationStatus" })
        @PATCH("saas/subscriptions/{subscriptionId}/operations/{operationId}")
        Observable<Response<ResponseBody>> updateOperationStatus(@Path("subscriptionId") UUID subscriptionId, @Path("operationId") UUID operationId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Body UpdateOperation body, @Header("User-Agent") String userAgent);

    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationList object if successful.
     */
    public OperationList listOperations(UUID subscriptionId) {
        return listOperationsWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationList> listOperationsAsync(UUID subscriptionId, final ServiceCallback<OperationList> serviceCallback) {
        return ServiceFuture.fromResponse(listOperationsWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationList object
     */
    public Observable<OperationList> listOperationsAsync(UUID subscriptionId) {
        return listOperationsWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<OperationList>, OperationList>() {
            @Override
            public OperationList call(ServiceResponse<OperationList> response) {
                return response.body();
            }
        });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationList object
     */
    public Observable<ServiceResponse<OperationList>> listOperationsWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.listOperations(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationList>>>() {
                @Override
                public Observable<ServiceResponse<OperationList>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationList> clientResponse = listOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the OperationList object if successful.
     */
    public OperationList listOperations(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return listOperationsWithServiceResponseAsync(subscriptionId, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<OperationList> listOperationsAsync(UUID subscriptionId, UUID requestId, UUID correlationId, final ServiceCallback<OperationList> serviceCallback) {
        return ServiceFuture.fromResponse(listOperationsWithServiceResponseAsync(subscriptionId, requestId, correlationId), serviceCallback);
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationList object
     */
    public Observable<OperationList> listOperationsAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return listOperationsWithServiceResponseAsync(subscriptionId, requestId, correlationId).map(new Func1<ServiceResponse<OperationList>, OperationList>() {
            @Override
            public OperationList call(ServiceResponse<OperationList> response) {
                return response.body();
            }
        });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the OperationList object
     */
    public Observable<ServiceResponse<OperationList>> listOperationsWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.listOperations(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationList>>>() {
                @Override
                public Observable<ServiceResponse<OperationList>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationList> clientResponse = listOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationList> listOperationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<OperationList, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<OperationList>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Operation object if successful.
     */
    public Operation getOperationStatus(UUID subscriptionId, UUID operationId) {
        return getOperationStatusWithServiceResponseAsync(subscriptionId, operationId).toBlocking().single().body();
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Operation> getOperationStatusAsync(UUID subscriptionId, UUID operationId, final ServiceCallback<Operation> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationStatusWithServiceResponseAsync(subscriptionId, operationId), serviceCallback);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<Operation> getOperationStatusAsync(UUID subscriptionId, UUID operationId) {
        return getOperationStatusWithServiceResponseAsync(subscriptionId, operationId).map(new Func1<ServiceResponse<Operation>, Operation>() {
            @Override
            public Operation call(ServiceResponse<Operation> response) {
                return response.body();
            }
        });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<ServiceResponse<Operation>> getOperationStatusWithServiceResponseAsync(UUID subscriptionId, UUID operationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.getOperationStatus(subscriptionId, operationId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Operation>>>() {
                @Override
                public Observable<ServiceResponse<Operation>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Operation> clientResponse = getOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Operation object if successful.
     */
    public Operation getOperationStatus(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId) {
        return getOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Operation> getOperationStatusAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId, final ServiceCallback<Operation> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId), serviceCallback);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<Operation> getOperationStatusAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId) {
        return getOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId).map(new Func1<ServiceResponse<Operation>, Operation>() {
            @Override
            public Operation call(ServiceResponse<Operation> response) {
                return response.body();
            }
        });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Operation object
     */
    public Observable<ServiceResponse<Operation>> getOperationStatusWithServiceResponseAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.getOperationStatus(subscriptionId, operationId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Operation>>>() {
                @Override
                public Observable<ServiceResponse<Operation>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Operation> clientResponse = getOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Operation> getOperationStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Operation, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Operation>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateOperationStatus(UUID subscriptionId, UUID operationId) {
        updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId).toBlocking().single().body();
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateOperationStatusAsync(UUID subscriptionId, UUID operationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId), serviceCallback);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateOperationStatusAsync(UUID subscriptionId, UUID operationId) {
        return updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateOperationStatusWithServiceResponseAsync(UUID subscriptionId, UUID operationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        final String planId = null;
        final Long quantity = null;
        final UpdateOperationStatusEnum status = null;
        UpdateOperation body = new UpdateOperation();
        body.withPlanId(null);
        body.withQuantity(null);
        body.withStatus(null);
        return service.updateOperationStatus(subscriptionId, operationId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param status Possible values include: 'Success', 'Failure'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateOperationStatus(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId, String planId, Long quantity, UpdateOperationStatusEnum status) {
        updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId, planId, quantity, status).toBlocking().single().body();
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param status Possible values include: 'Success', 'Failure'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateOperationStatusAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId, String planId, Long quantity, UpdateOperationStatusEnum status, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId, planId, quantity, status), serviceCallback);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param status Possible values include: 'Success', 'Failure'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateOperationStatusAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId, String planId, Long quantity, UpdateOperationStatusEnum status) {
        return updateOperationStatusWithServiceResponseAsync(subscriptionId, operationId, requestId, correlationId, planId, quantity, status).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param status Possible values include: 'Success', 'Failure'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateOperationStatusWithServiceResponseAsync(UUID subscriptionId, UUID operationId, UUID requestId, UUID correlationId, String planId, Long quantity, UpdateOperationStatusEnum status) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        UpdateOperation body = new UpdateOperation();
        body.withPlanId(planId);
        body.withQuantity(quantity);
        body.withStatus(status);
        return service.updateOperationStatus(subscriptionId, operationId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateOperationStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateOperationStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
