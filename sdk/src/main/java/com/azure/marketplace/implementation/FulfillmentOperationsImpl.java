/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.azure.marketplace.implementation;

import retrofit2.Retrofit;
import com.azure.marketplace.FulfillmentOperations;
import com.azure.marketplace.models.FulfillmentOperationsDeleteSubscriptionHeaders;
import com.azure.marketplace.models.FulfillmentOperationsUpdateSubscriptionHeaders;
import com.azure.marketplace.models.PageImpl;
import com.azure.marketplace.models.ResolvedSubscription;
import com.azure.marketplace.models.SubscriberPlan;
import com.azure.marketplace.models.Subscription;
import com.azure.marketplace.models.SubscriptionPlans;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseWithHeaders;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in FulfillmentOperations.
 */
public class FulfillmentOperationsImpl implements FulfillmentOperations {
    /** The Retrofit service to perform REST calls. */
    private FulfillmentOperationsService service;
    /** The service client containing this operation class. */
    private MarketplaceClientImpl client;

    /**
     * Initializes an instance of FulfillmentOperationsImpl.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public FulfillmentOperationsImpl(Retrofit retrofit, MarketplaceClientImpl client) {
        this.service = retrofit.create(FulfillmentOperationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for FulfillmentOperations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface FulfillmentOperationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations resolve" })
        @POST("saas/subscriptions/resolve")
        Observable<Response<ResponseBody>> resolve(@Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("x-ms-marketplace-token") String xMsMarketplaceToken, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations listSubscriptions" })
        @GET("saas/subscriptions/")
        Observable<Response<ResponseBody>> listSubscriptions(@Query("api-version") String apiVersion, @Query("continuationToken") String continuationToken, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations getSubscription" })
        @GET("saas/subscriptions/{subscriptionId}")
        Observable<Response<ResponseBody>> getSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations updateSubscription" })
        @PATCH("saas/subscriptions/{subscriptionId}")
        Observable<Response<ResponseBody>> updateSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Body SubscriberPlan body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations deleteSubscription" })
        @HTTP(path = "saas/subscriptions/{subscriptionId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations listAvailablePlans" })
        @GET("saas/subscriptions/{subscriptionId}/listAvailablePlans")
        Observable<Response<ResponseBody>> listAvailablePlans(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations activateSubscription" })
        @POST("saas/subscriptions/{subscriptionId}/activate")
        Observable<Response<ResponseBody>> activateSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Body SubscriberPlan body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.azure.marketplace.FulfillmentOperations listSubscriptionsNext" })
        @GET
        Observable<Response<ResponseBody>> listSubscriptionsNext(@Url String nextUrl, @Header("x-ms-requestid") UUID requestId, @Header("x-ms-correlationid") UUID correlationId, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResolvedSubscription object if successful.
     */
    public ResolvedSubscription resolve(String xMsMarketplaceToken) {
        return resolveWithServiceResponseAsync(xMsMarketplaceToken).toBlocking().single().body();
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResolvedSubscription> resolveAsync(String xMsMarketplaceToken, final ServiceCallback<ResolvedSubscription> serviceCallback) {
        return ServiceFuture.fromResponse(resolveWithServiceResponseAsync(xMsMarketplaceToken), serviceCallback);
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedSubscription object
     */
    public Observable<ResolvedSubscription> resolveAsync(String xMsMarketplaceToken) {
        return resolveWithServiceResponseAsync(xMsMarketplaceToken).map(new Func1<ServiceResponse<ResolvedSubscription>, ResolvedSubscription>() {
            @Override
            public ResolvedSubscription call(ServiceResponse<ResolvedSubscription> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedSubscription object
     */
    public Observable<ServiceResponse<ResolvedSubscription>> resolveWithServiceResponseAsync(String xMsMarketplaceToken) {
        if (xMsMarketplaceToken == null) {
            throw new IllegalArgumentException("Parameter xMsMarketplaceToken is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.resolve(apiVersion, requestId, correlationId, xMsMarketplaceToken, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResolvedSubscription>>>() {
                @Override
                public Observable<ServiceResponse<ResolvedSubscription>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResolvedSubscription> clientResponse = resolveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ResolvedSubscription object if successful.
     */
    public ResolvedSubscription resolve(String xMsMarketplaceToken, UUID requestId, UUID correlationId) {
        return resolveWithServiceResponseAsync(xMsMarketplaceToken, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ResolvedSubscription> resolveAsync(String xMsMarketplaceToken, UUID requestId, UUID correlationId, final ServiceCallback<ResolvedSubscription> serviceCallback) {
        return ServiceFuture.fromResponse(resolveWithServiceResponseAsync(xMsMarketplaceToken, requestId, correlationId), serviceCallback);
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedSubscription object
     */
    public Observable<ResolvedSubscription> resolveAsync(String xMsMarketplaceToken, UUID requestId, UUID correlationId) {
        return resolveWithServiceResponseAsync(xMsMarketplaceToken, requestId, correlationId).map(new Func1<ServiceResponse<ResolvedSubscription>, ResolvedSubscription>() {
            @Override
            public ResolvedSubscription call(ServiceResponse<ResolvedSubscription> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ResolvedSubscription object
     */
    public Observable<ServiceResponse<ResolvedSubscription>> resolveWithServiceResponseAsync(String xMsMarketplaceToken, UUID requestId, UUID correlationId) {
        if (xMsMarketplaceToken == null) {
            throw new IllegalArgumentException("Parameter xMsMarketplaceToken is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.resolve(apiVersion, requestId, correlationId, xMsMarketplaceToken, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResolvedSubscription>>>() {
                @Override
                public Observable<ServiceResponse<ResolvedSubscription>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResolvedSubscription> clientResponse = resolveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ResolvedSubscription> resolveDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ResolvedSubscription, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ResolvedSubscription>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;Subscription&gt; object if successful.
     */
    public PagedList<Subscription> listSubscriptions() {
        ServiceResponse<Page<Subscription>> response = listSubscriptionsSinglePageAsync().toBlocking().single();
        return new PagedList<Subscription>(response.body()) {
            @Override
            public Page<Subscription> nextPage(String nextPageLink) {
                return listSubscriptionsNextSinglePageAsync(nextPageLink, null, null).toBlocking().single().body();
            }
        };
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Subscription>> listSubscriptionsAsync(final ListOperationCallback<Subscription> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSubscriptionsSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(String nextPageLink) {
                    return listSubscriptionsNextSinglePageAsync(nextPageLink, null, null);
                }
            },
            serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<Page<Subscription>> listSubscriptionsAsync() {
        return listSubscriptionsWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<Subscription>>, Page<Subscription>>() {
                @Override
                public Page<Subscription> call(ServiceResponse<Page<Subscription>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsWithServiceResponseAsync() {
        return listSubscriptionsSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<Subscription>>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(ServiceResponse<Page<Subscription>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSubscriptionsNextWithServiceResponseAsync(nextPageLink, null, null));
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;Subscription&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsSinglePageAsync() {
        final String apiVersion = "2018-08-31";
        final String continuationToken = null;
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.listSubscriptions(apiVersion, continuationToken, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<Subscription>> result = listSubscriptionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<Subscription>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param continuationToken Optional value, only used for ListSubscriptions.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;Subscription&gt; object if successful.
     */
    public PagedList<Subscription> listSubscriptions(final String continuationToken, final UUID requestId, final UUID correlationId) {
        ServiceResponse<Page<Subscription>> response = listSubscriptionsSinglePageAsync(continuationToken, requestId, correlationId).toBlocking().single();
        return new PagedList<Subscription>(response.body()) {
            @Override
            public Page<Subscription> nextPage(String nextPageLink) {
                return listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId).toBlocking().single().body();
            }
        };
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param continuationToken Optional value, only used for ListSubscriptions.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Subscription>> listSubscriptionsAsync(final String continuationToken, final UUID requestId, final UUID correlationId, final ListOperationCallback<Subscription> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSubscriptionsSinglePageAsync(continuationToken, requestId, correlationId),
            new Func1<String, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(String nextPageLink) {
                    return listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId);
                }
            },
            serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param continuationToken Optional value, only used for ListSubscriptions.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<Page<Subscription>> listSubscriptionsAsync(final String continuationToken, final UUID requestId, final UUID correlationId) {
        return listSubscriptionsWithServiceResponseAsync(continuationToken, requestId, correlationId)
            .map(new Func1<ServiceResponse<Page<Subscription>>, Page<Subscription>>() {
                @Override
                public Page<Subscription> call(ServiceResponse<Page<Subscription>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param continuationToken Optional value, only used for ListSubscriptions.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsWithServiceResponseAsync(final String continuationToken, final UUID requestId, final UUID correlationId) {
        return listSubscriptionsSinglePageAsync(continuationToken, requestId, correlationId)
            .concatMap(new Func1<ServiceResponse<Page<Subscription>>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(ServiceResponse<Page<Subscription>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSubscriptionsNextWithServiceResponseAsync(nextPageLink, requestId, correlationId));
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param continuationToken Optional value, only used for ListSubscriptions.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;Subscription&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsSinglePageAsync(final String continuationToken, final UUID requestId, final UUID correlationId) {
        final String apiVersion = "2018-08-31";
        return service.listSubscriptions(apiVersion, continuationToken, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<Subscription>> result = listSubscriptionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<Subscription>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<Subscription>> listSubscriptionsDelegate(Response<ResponseBody> response) throws CloudException, IOException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<Subscription>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<Subscription>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Subscription object if successful.
     */
    public Subscription getSubscription(UUID subscriptionId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Subscription> getSubscriptionAsync(UUID subscriptionId, final ServiceCallback<Subscription> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Subscription object
     */
    public Observable<Subscription> getSubscriptionAsync(UUID subscriptionId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<Subscription>, Subscription>() {
            @Override
            public Subscription call(ServiceResponse<Subscription> response) {
                return response.body();
            }
        });
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Subscription object
     */
    public Observable<ServiceResponse<Subscription>> getSubscriptionWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.getSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Subscription>>>() {
                @Override
                public Observable<ServiceResponse<Subscription>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Subscription> clientResponse = getSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Subscription object if successful.
     */
    public Subscription getSubscription(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Subscription> getSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, final ServiceCallback<Subscription> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId), serviceCallback);
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Subscription object
     */
    public Observable<Subscription> getSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId).map(new Func1<ServiceResponse<Subscription>, Subscription>() {
            @Override
            public Subscription call(ServiceResponse<Subscription> response) {
                return response.body();
            }
        });
    }

    /**
     * Get subscription.
     * Gets the specified SaaS subscription. Use this call to get license information and plan information.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Subscription object
     */
    public Observable<ServiceResponse<Subscription>> getSubscriptionWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.getSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Subscription>>>() {
                @Override
                public Observable<ServiceResponse<Subscription>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Subscription> clientResponse = getSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Subscription> getSubscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Subscription, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Subscription>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateSubscription(UUID subscriptionId) {
        updateSubscriptionWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateSubscriptionAsync(UUID subscriptionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSubscriptionWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateSubscriptionAsync(UUID subscriptionId) {
        return updateSubscriptionWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>> updateSubscriptionWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        final String planId = null;
        final Long quantity = null;
        SubscriberPlan body = new SubscriberPlan();
        body.withPlanId(null);
        body.withQuantity(null);
        return service.updateSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders> clientResponse = updateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateSubscription(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        updateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity).toBlocking().single().body();
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity), serviceCallback);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> updateSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        return updateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity).map(new Func1<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>> updateSubscriptionWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        SubscriberPlan body = new SubscriberPlan();
        body.withPlanId(planId);
        body.withQuantity(quantity);
        return service.updateSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders> clientResponse = updateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, FulfillmentOperationsUpdateSubscriptionHeaders> updateSubscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, FulfillmentOperationsUpdateSubscriptionHeaders.class);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSubscription(UUID subscriptionId) {
        deleteSubscriptionWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSubscriptionAsync(UUID subscriptionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteSubscriptionWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deleteSubscriptionAsync(UUID subscriptionId) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>> deleteSubscriptionWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.deleteSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders> clientResponse = deleteSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteSubscription(UUID subscriptionId, UUID requestId, UUID correlationId) {
        deleteSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId), serviceCallback);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deleteSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId).map(new Func1<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>> deleteSubscriptionWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.deleteSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders> clientResponse = deleteSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, FulfillmentOperationsDeleteSubscriptionHeaders> deleteSubscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .buildWithHeaders(response, FulfillmentOperationsDeleteSubscriptionHeaders.class);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionPlans object if successful.
     */
    public SubscriptionPlans listAvailablePlans(UUID subscriptionId) {
        return listAvailablePlansWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionPlans> listAvailablePlansAsync(UUID subscriptionId, final ServiceCallback<SubscriptionPlans> serviceCallback) {
        return ServiceFuture.fromResponse(listAvailablePlansWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionPlans object
     */
    public Observable<SubscriptionPlans> listAvailablePlansAsync(UUID subscriptionId) {
        return listAvailablePlansWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<SubscriptionPlans>, SubscriptionPlans>() {
            @Override
            public SubscriptionPlans call(ServiceResponse<SubscriptionPlans> response) {
                return response.body();
            }
        });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionPlans object
     */
    public Observable<ServiceResponse<SubscriptionPlans>> listAvailablePlansWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        return service.listAvailablePlans(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SubscriptionPlans>>>() {
                @Override
                public Observable<ServiceResponse<SubscriptionPlans>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SubscriptionPlans> clientResponse = listAvailablePlansDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionPlans object if successful.
     */
    public SubscriptionPlans listAvailablePlans(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return listAvailablePlansWithServiceResponseAsync(subscriptionId, requestId, correlationId).toBlocking().single().body();
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionPlans> listAvailablePlansAsync(UUID subscriptionId, UUID requestId, UUID correlationId, final ServiceCallback<SubscriptionPlans> serviceCallback) {
        return ServiceFuture.fromResponse(listAvailablePlansWithServiceResponseAsync(subscriptionId, requestId, correlationId), serviceCallback);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionPlans object
     */
    public Observable<SubscriptionPlans> listAvailablePlansAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        return listAvailablePlansWithServiceResponseAsync(subscriptionId, requestId, correlationId).map(new Func1<ServiceResponse<SubscriptionPlans>, SubscriptionPlans>() {
            @Override
            public SubscriptionPlans call(ServiceResponse<SubscriptionPlans> response) {
                return response.body();
            }
        });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionPlans object
     */
    public Observable<ServiceResponse<SubscriptionPlans>> listAvailablePlansWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        return service.listAvailablePlans(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SubscriptionPlans>>>() {
                @Override
                public Observable<ServiceResponse<SubscriptionPlans>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SubscriptionPlans> clientResponse = listAvailablePlansDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SubscriptionPlans> listAvailablePlansDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SubscriptionPlans, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SubscriptionPlans>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void activateSubscription(UUID subscriptionId) {
        activateSubscriptionWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> activateSubscriptionAsync(UUID subscriptionId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(activateSubscriptionWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> activateSubscriptionAsync(UUID subscriptionId) {
        return activateSubscriptionWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> activateSubscriptionWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        final UUID requestId = null;
        final UUID correlationId = null;
        final String planId = null;
        final Long quantity = null;
        SubscriberPlan body = new SubscriberPlan();
        body.withPlanId(null);
        body.withQuantity(null);
        return service.activateSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = activateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void activateSubscription(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        activateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity).toBlocking().single().body();
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> activateSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(activateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity), serviceCallback);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> activateSubscriptionAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        return activateSubscriptionWithServiceResponseAsync(subscriptionId, requestId, correlationId, planId, quantity).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param subscriptionId the UUID value
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param planId the String value
     * @param quantity the Long value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> activateSubscriptionWithServiceResponseAsync(UUID subscriptionId, UUID requestId, UUID correlationId, String planId, Long quantity) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2018-08-31";
        SubscriberPlan body = new SubscriberPlan();
        body.withPlanId(planId);
        body.withQuantity(quantity);
        return service.activateSubscription(subscriptionId, apiVersion, requestId, correlationId, this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = activateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> activateSubscriptionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;Subscription&gt; object if successful.
     */
    public PagedList<Subscription> listSubscriptionsNext(final String nextPageLink) {
        ServiceResponse<Page<Subscription>> response = listSubscriptionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<Subscription>(response.body()) {
            @Override
            public Page<Subscription> nextPage(String nextPageLink) {
                return listSubscriptionsNextSinglePageAsync(nextPageLink, null, null).toBlocking().single().body();
            }
        };
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Subscription>> listSubscriptionsNextAsync(final String nextPageLink, final ServiceFuture<List<Subscription>> serviceFuture, final ListOperationCallback<Subscription> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSubscriptionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(String nextPageLink) {
                    return listSubscriptionsNextSinglePageAsync(nextPageLink, null, null);
                }
            },
            serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<Page<Subscription>> listSubscriptionsNextAsync(final String nextPageLink) {
        return listSubscriptionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<Subscription>>, Page<Subscription>>() {
                @Override
                public Page<Subscription> call(ServiceResponse<Page<Subscription>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSubscriptionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<Subscription>>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(ServiceResponse<Page<Subscription>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSubscriptionsNextWithServiceResponseAsync(nextPageLink, null, null));
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;Subscription&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        final UUID requestId = null;
        final UUID correlationId = null;
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSubscriptionsNext(nextUrl, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<Subscription>> result = listSubscriptionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<Subscription>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;Subscription&gt; object if successful.
     */
    public PagedList<Subscription> listSubscriptionsNext(final String nextPageLink, final UUID requestId, final UUID correlationId) {
        ServiceResponse<Page<Subscription>> response = listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId).toBlocking().single();
        return new PagedList<Subscription>(response.body()) {
            @Override
            public Page<Subscription> nextPage(String nextPageLink) {
                return listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId).toBlocking().single().body();
            }
        };
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Subscription>> listSubscriptionsNextAsync(final String nextPageLink, final UUID requestId, final UUID correlationId, final ServiceFuture<List<Subscription>> serviceFuture, final ListOperationCallback<Subscription> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId),
            new Func1<String, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(String nextPageLink) {
                    return listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId);
                }
            },
            serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<Page<Subscription>> listSubscriptionsNextAsync(final String nextPageLink, final UUID requestId, final UUID correlationId) {
        return listSubscriptionsNextWithServiceResponseAsync(nextPageLink, requestId, correlationId)
            .map(new Func1<ServiceResponse<Page<Subscription>>, Page<Subscription>>() {
                @Override
                public Page<Subscription> call(ServiceResponse<Page<Subscription>> response) {
                    return response.body();
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;Subscription&gt; object
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsNextWithServiceResponseAsync(final String nextPageLink, final UUID requestId, final UUID correlationId) {
        return listSubscriptionsNextSinglePageAsync(nextPageLink, requestId, correlationId)
            .concatMap(new Func1<ServiceResponse<Page<Subscription>>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(ServiceResponse<Page<Subscription>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSubscriptionsNextWithServiceResponseAsync(nextPageLink, requestId, correlationId));
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param requestId A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param correlationId A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;Subscription&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<Subscription>>> listSubscriptionsNextSinglePageAsync(final String nextPageLink, final UUID requestId, final UUID correlationId) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listSubscriptionsNext(nextUrl, requestId, correlationId, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<Subscription>>>>() {
                @Override
                public Observable<ServiceResponse<Page<Subscription>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<Subscription>> result = listSubscriptionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<Subscription>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<Subscription>> listSubscriptionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<Subscription>, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<Subscription>>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
